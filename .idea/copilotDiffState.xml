<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/arpackagevalidator/ui/MeasurementMode.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/arpackagevalidator/ui/MeasurementMode.kt" />
              <option name="originalContent" value="package com.example.arpackagevalidator.ui&#10;&#10;enum class MeasurementMode {&#10;    FREE,&#10;    BOX&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.arpackagevalidator.ui&#10;&#10;enum class MeasurementMode {&#10;    BOX&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/arpackagevalidator/ui/viewmodel/MeasurementViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/arpackagevalidator/ui/viewmodel/MeasurementViewModel.kt" />
              <option name="originalContent" value="package com.example.arpackagevalidator.ui.viewmodel&#10;&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.ViewModel&#10;import com.example.arpackagevalidator.data.MeasurementData&#10;import com.example.arpackagevalidator.ui.MeasurementMode&#10;import com.google.ar.sceneform.math.Vector3&#10;import java.util.Date&#10;import kotlin.math.abs&#10;import kotlin.math.sqrt&#10;&#10;// Move BoxMeasurementStep enum outside the class so it can be accessed by other files&#10;enum class BoxMeasurementStep {&#10;    SET_ORIGIN,&#10;    SET_LENGTH,&#10;    SET_WIDTH,&#10;    SET_HEIGHT,&#10;    DONE&#10;}&#10;&#10;class MeasurementViewModel : ViewModel() {&#10;    private val _measurementData = MutableLiveData&lt;MeasurementData&gt;()&#10;    val measurementData: LiveData&lt;MeasurementData&gt; get() = _measurementData&#10;&#10;    private val _currentStep = MutableLiveData&lt;BoxMeasurementStep&gt;(BoxMeasurementStep.SET_ORIGIN)&#10;    val currentStep: LiveData&lt;BoxMeasurementStep&gt; get() = _currentStep&#10;&#10;    private val _measurementMode = MutableLiveData&lt;MeasurementMode&gt;(MeasurementMode.LENGTH)&#10;    val measurementMode: LiveData&lt;MeasurementMode&gt; get() = _measurementMode&#10;&#10;    private val _origin = MutableLiveData&lt;Vector3&gt;()&#10;    val origin: LiveData&lt;Vector3&gt; get() = _origin&#10;&#10;    private val _length = MutableLiveData&lt;Float&gt;()&#10;    val length: LiveData&lt;Float&gt; get() = _length&#10;&#10;    private val _width = MutableLiveData&lt;Float&gt;()&#10;    val width: LiveData&lt;Float&gt; get() = _width&#10;&#10;    private val _height = MutableLiveData&lt;Float&gt;()&#10;    val height: LiveData&lt;Float&gt; get() = _height&#10;&#10;    private val _volume = MutableLiveData&lt;Float&gt;()&#10;    val volume: LiveData&lt;Float&gt; get() = _volume&#10;&#10;    private val _surfaceArea = MutableLiveData&lt;Float&gt;()&#10;    val surfaceArea: LiveData&lt;Float&gt; get() = _surfaceArea&#10;&#10;    private val _date = MutableLiveData&lt;Date&gt;()&#10;    val date: LiveData&lt;Date&gt; get() = _date&#10;&#10;    private val _isDataValid = MutableLiveData&lt;Boolean&gt;(false)&#10;    val isDataValid: LiveData&lt;Boolean&gt; get() = _isDataValid&#10;&#10;    fun setOrigin(vector: Vector3) {&#10;        _origin.value = vector&#10;        _currentStep.value = BoxMeasurementStep.SET_LENGTH&#10;    }&#10;&#10;    fun setLength(length: Float) {&#10;        _length.value = length&#10;        _currentStep.value = BoxMeasurementStep.SET_WIDTH&#10;    }&#10;&#10;    fun setWidth(width: Float) {&#10;        _width.value = width&#10;        _currentStep.value = BoxMeasurementStep.SET_HEIGHT&#10;    }&#10;&#10;    fun setHeight(height: Float) {&#10;        _height.value = height&#10;        _currentStep.value = BoxMeasurementStep.DONE&#10;    }&#10;&#10;    fun calculateVolume() {&#10;        val length = _length.value ?: 0f&#10;        val width = _width.value ?: 0f&#10;        val height = _height.value ?: 0f&#10;        _volume.value = length * width * height&#10;    }&#10;&#10;    fun calculateSurfaceArea() {&#10;        val length = _length.value ?: 0f&#10;        val width = _width.value ?: 0f&#10;        val height = _height.value ?: 0f&#10;        _surfaceArea.value = 2 * (length * width + width * height + length * height)&#10;    }&#10;&#10;    fun validateData() {&#10;        _isDataValid.value = (_length.value != null &amp;&amp; _width.value != null &amp;&amp; _height.value != null)&#10;    }&#10;&#10;    // ...existing code...&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.arpackagevalidator.ui.viewmodel&#10;&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.ViewModel&#10;import com.example.arpackagevalidator.data.MeasurementData&#10;import com.example.arpackagevalidator.ui.MeasurementMode&#10;import com.google.ar.sceneform.math.Vector3&#10;import java.util.Date&#10;import kotlin.math.abs&#10;import kotlin.math.sqrt&#10;&#10;// Move BoxMeasurementStep enum outside the class so it can be accessed by other files&#10;enum class BoxMeasurementStep {&#10;    SET_ORIGIN,&#10;    SET_LENGTH,&#10;    SET_WIDTH,&#10;    SET_HEIGHT,&#10;    DONE&#10;}&#10;&#10;class MeasurementViewModel : ViewModel() {&#10;&#10;    private val _uiState = MutableLiveData&lt;MeasurementUiState&gt;()&#10;    val uiState: LiveData&lt;MeasurementUiState&gt; = _uiState&#10;&#10;    private var calibrationFactor = 1.0f&#10;    private var currentPoints = mutableListOf&lt;Vector3&gt;()&#10;    private var knownCalibrationDistance = 0f&#10;&#10;    init {&#10;        _uiState.value = MeasurementUiState()&#10;    }&#10;&#10;    fun onModeChanged(mode: MeasurementMode) {&#10;        reset()&#10;        _uiState.value = _uiState.value?.copy(mode = mode)&#10;    }&#10;&#10;    fun onArTap(position: Vector3) {&#10;        val state = _uiState.value ?: return&#10;        if (!state.isPlacing) return&#10;&#10;        currentPoints.add(position)&#10;&#10;        if (state.isCalibrating) {&#10;            handleCalibrationStep()&#10;        } else {&#10;            // Only handle BOX mode since FREE mode is removed&#10;            handleBoxMeasurement()&#10;        }&#10;    }&#10;&#10;    private fun handleCalibrationStep() {&#10;        if (currentPoints.size &gt;= 2) {&#10;            val measuredDistance = calculateDistance(currentPoints[0], currentPoints[1])&#10;            if (measuredDistance &gt; 0.001f &amp;&amp; knownCalibrationDistance &gt; 0) {&#10;                this.calibrationFactor = knownCalibrationDistance / (measuredDistance * 100f)&#10;                val message = &quot;Kalibrasi berhasil! Faktor baru: %.3f&quot;.format(this.calibrationFactor)&#10;                _uiState.value = _uiState.value?.copy(&#10;                    isCalibrating = false,&#10;                    isPlacing = false,&#10;                    userMessage = message,&#10;                    points = currentPoints.toList()&#10;                )&#10;            } else {&#10;                reset()&#10;                _uiState.value = _uiState.value?.copy(userMessage = &quot;Error kalibrasi. Jarak tidak valid.&quot;)&#10;            }&#10;        } else {&#10;            _uiState.value = _uiState.value?.copy(userMessage = &quot;Tap titik kedua untuk menyelesaikan kalibrasi.&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleBoxMeasurement() {&#10;        val state = _uiState.value ?: return&#10;        var length = state.length&#10;        var width = state.width&#10;        var height = state.height&#10;        var classification = state.classification&#10;        var nextStep = state.boxStep&#10;&#10;        when (state.boxStep) {&#10;            BoxMeasurementStep.SET_ORIGIN -&gt; nextStep = BoxMeasurementStep.SET_LENGTH&#10;            BoxMeasurementStep.SET_LENGTH -&gt; {&#10;                length = calculateDistance(currentPoints[0], currentPoints[1]) * 100f * this.calibrationFactor&#10;                nextStep = BoxMeasurementStep.SET_WIDTH&#10;            }&#10;            BoxMeasurementStep.SET_WIDTH -&gt; {&#10;                width = calculateDistance(currentPoints[0], currentPoints[2]) * 100f * this.calibrationFactor&#10;                nextStep = BoxMeasurementStep.SET_HEIGHT&#10;            }&#10;            BoxMeasurementStep.SET_HEIGHT -&gt; {&#10;                height = abs(currentPoints[3].y - currentPoints[0].y) * 100f * this.calibrationFactor&#10;                classification = classifyPackage(length, width, height)&#10;                nextStep = BoxMeasurementStep.DONE&#10;            }&#10;            BoxMeasurementStep.DONE -&gt; { /* Do nothing */ }&#10;        }&#10;&#10;        _uiState.value = state.copy(&#10;            points = currentPoints.toList(),&#10;            length = length,&#10;            width = width,&#10;            height = height,&#10;            classification = classification,&#10;            boxStep = nextStep,&#10;            isPlacing = nextStep != BoxMeasurementStep.DONE,&#10;            isUndoEnabled = currentPoints.isNotEmpty(),&#10;            isSaveEnabled = nextStep == BoxMeasurementStep.DONE,&#10;            userMessage = generateUserMessage(nextStep, state.mode)&#10;        )&#10;    }&#10;&#10;    fun startMeasurement() {&#10;        val state = _uiState.value ?: return&#10;        if (state.isPlacing) {&#10;            reset()&#10;        } else {&#10;            reset()&#10;            _uiState.value = _uiState.value?.copy(&#10;                isPlacing = true,&#10;                userMessage = generateUserMessage(BoxMeasurementStep.SET_ORIGIN, state.mode)&#10;            )&#10;        }&#10;    }&#10;&#10;    fun startCalibration(knownDistanceCm: Float) {&#10;        reset()&#10;        this.knownCalibrationDistance = knownDistanceCm&#10;        _uiState.value = _uiState.value?.copy(&#10;            isCalibrating = true,&#10;            isPlacing = true,&#10;            userMessage = &quot;Tap dua titik yang berjarak %.1f cm&quot;.format(knownDistanceCm)&#10;        )&#10;    }&#10;&#10;    fun reset() {&#10;        currentPoints.clear()&#10;        _uiState.value = _uiState.value?.copy(&#10;            isPlacing = false,&#10;            isCalibrating = false,&#10;            points = emptyList(),&#10;            length = 0f,&#10;            width = 0f,&#10;            height = 0f,&#10;            classification = &quot;&quot;,&#10;            isUndoEnabled = false,&#10;            isSaveEnabled = false,&#10;            boxStep = BoxMeasurementStep.SET_ORIGIN,&#10;            userMessage = &quot;Pengukuran direset. Tekan 'Mulai Ukur'.&quot;&#10;        )&#10;    }&#10;&#10;    fun undo() {&#10;        if (currentPoints.isNotEmpty()) {&#10;            val state = _uiState.value ?: return&#10;            currentPoints.removeAt(currentPoints.lastIndex)&#10;&#10;            val prevStep = when (state.boxStep) {&#10;                BoxMeasurementStep.DONE -&gt; BoxMeasurementStep.SET_HEIGHT&#10;                BoxMeasurementStep.SET_HEIGHT -&gt; BoxMeasurementStep.SET_WIDTH&#10;                BoxMeasurementStep.SET_WIDTH -&gt; BoxMeasurementStep.SET_LENGTH&#10;                BoxMeasurementStep.SET_LENGTH -&gt; BoxMeasurementStep.SET_ORIGIN&#10;                BoxMeasurementStep.SET_ORIGIN -&gt; BoxMeasurementStep.SET_ORIGIN&#10;            }&#10;&#10;            _uiState.value = state.copy(&#10;                points = currentPoints.toList(),&#10;                boxStep = prevStep,&#10;                isUndoEnabled = currentPoints.isNotEmpty(),&#10;                isSaveEnabled = false,&#10;                userMessage = &quot;Titik terakhir dihapus&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    fun saveCurrentMeasurement(): MeasurementData? {&#10;        val state = uiState.value ?: return null&#10;        if (!state.isSaveEnabled) return null&#10;&#10;        return MeasurementData(&#10;            id = System.currentTimeMillis(),&#10;            timestamp = Date(),&#10;            mode = state.mode.name,&#10;            length = state.length,&#10;            width = state.width,&#10;            height = state.height,&#10;            volume = calculateVolume(state.length, state.width, state.height),&#10;            classification = state.classification,&#10;            points = state.points.map { vector -&gt; listOf(vector.x, vector.y, vector.z) }&#10;        )&#10;    }&#10;&#10;    private fun calculateVolume(length: Float, width: Float, height: Float): Float {&#10;        return length * width * height&#10;    }&#10;&#10;    private fun generateUserMessage(step: BoxMeasurementStep, mode: MeasurementMode): String {&#10;        return when (step) {&#10;            BoxMeasurementStep.SET_ORIGIN -&gt; &quot;Tap untuk menentukan titik AWAL kotak.&quot;&#10;            BoxMeasurementStep.SET_LENGTH -&gt; &quot;Tap untuk menentukan PANJANG.&quot;&#10;            BoxMeasurementStep.SET_WIDTH -&gt; &quot;Tap untuk menentukan LEBAR.&quot;&#10;            BoxMeasurementStep.SET_HEIGHT -&gt; &quot;Tap untuk menentukan TINGGI.&quot;&#10;            BoxMeasurementStep.DONE -&gt; &quot;Pengukuran kotak selesai!&quot;&#10;        }&#10;    }&#10;&#10;    private fun calculateDistance(p1: Vector3, p2: Vector3): Float {&#10;        val dx = p1.x - p2.x&#10;        val dy = p1.y - p2.y&#10;        val dz = p1.z - p2.z&#10;        return sqrt((dx * dx) + (dy * dy) + (dz * dz)).toFloat()&#10;    }&#10;&#10;    private fun classifyPackage(length: Float, width: Float, height: Float): String {&#10;        val maxDimension = maxOf(length, width, height)&#10;        val volumeCm3 = length * width * height&#10;        return when {&#10;            maxDimension &lt;= 20 &amp;&amp; volumeCm3 &lt;= 5000 -&gt; &quot;SMALL&quot;&#10;            maxDimension &lt;= 40 &amp;&amp; volumeCm3 &lt;= 30000 -&gt; &quot;MEDIUM&quot;&#10;            maxDimension &lt;= 60 &amp;&amp; volumeCm3 &lt;= 100000 -&gt; &quot;LARGE&quot;&#10;            else -&gt; &quot;EXTRA LARGE&quot;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>